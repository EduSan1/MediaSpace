"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.explainAsync = explainAsync;
exports.organizeExplanations = organizeExplanations;
exports.printExplanationsAsync = printExplanationsAsync;
exports.warnAboutDeepDependenciesAsync = warnAboutDeepDependenciesAsync;

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _ora() {
  const data = require("../../../../utils/ora");

  _ora = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isSpawnResult(result) {
  return 'stderr' in result && 'stdout' in result && 'status' in result;
}
/** Spawn `npm explain [name] --json` and return the parsed JSON. Returns `null` if the requested package is not installed. */


async function explainAsync(packageName, parameters = []) {
  const ora = (0, _ora().logNewSection)(`Finding all copies of ${packageName}`);
  const args = ['explain', packageName, ...parameters, '--json'];

  try {
    const {
      stdout
    } = await (0, _spawnAsync().default)('npm', args, {
      stdio: 'pipe'
    });
    ora.stop();
    return JSON.parse(stdout);
  } catch (error) {
    if (isSpawnResult(error)) {
      if (error.stderr.match(/npm ERR! No dependencies found matching/)) {
        ora.stop();
        return null;
      } else if (error.stdout.match(/Usage: npm <command>/)) {
        ora.fail(`Dependency tree validation for ${_chalk().default.underline(packageName)} failed. This validation is only available on Node 16+ / npm 8.`);
        return null;
      }
    }

    ora.fail(`Failed to find dependency tree for ${packageName}: ` + error.message);
    throw error;
  }
}
/**
 * @param pkg
 * @returns true if all versions of the package satisfy the constraints
 */


async function warnAboutDeepDependenciesAsync(pkg) {
  const explanations = await explainAsync(pkg.name);

  if (!explanations) {
    _log().default.debug(`No dependencies found for ${pkg.name}`);

    return true;
  }

  return printExplanationsAsync(pkg, explanations);
}

function organizeExplanations(pkg, {
  explanations,
  isValid
}) {
  const valid = [];
  const invalid = [];

  for (const explanation of explanations) {
    const {
      name
    } = explanation;

    if (name === pkg.name) {
      if (isValid(explanation)) {
        valid.push(explanation);
      } else {
        invalid.push(explanation);
      }
    } else {
      // Should never happen
      _log().default.warn(`Found invalid case where the searched package name "${name}" doesn't match requested package name "${pkg.name}"`);
    }
  }

  return {
    valid,
    invalid
  };
}
/**
 * @param pkg
 * @param explanations
 * @returns true if all versions of the package satisfy the constraints
 */


async function printExplanationsAsync(pkg, explanations) {
  const {
    invalid
  } = organizeExplanations(pkg, {
    explanations,

    isValid(otherPkg) {
      return _semver().default.satisfies(otherPkg.version, pkg.version);
    }

  });

  if (invalid.length > 0) {
    printInvalidPackages(pkg, {
      explanations: invalid
    });
    return false;
  } else {
    _log().default.debug((0, _chalk().default)`All copies of {bold ${pkg.name}} satisfy {green ${pkg.version}}`);

    return true;
  }
}

function printInvalidPackages(pkg, {
  explanations
}) {
  if (pkg.version) {
    _log().default.warn(`Expected package ${formatPkg(pkg, 'green')}`);
  } else {
    _log().default.warn(`Expected to not find any copies of ${formatPkg(pkg, 'green')}`);
  }

  _log().default.warn((0, _chalk().default)`Found invalid:`);

  _log().default.warn(explanations.map(explanation => '  ' + formatPkg(explanation, 'red')).join('\n'));

  _log().default.warn((0, _chalk().default)`  {dim (for more info, run: {bold npm why ${pkg.name}})}`); // Log.log(invalid.map(explanation => explainNode(explanation)).join('\n\n'));

}

function formatPkg(pkg, versionColor) {
  if (pkg.version) {
    return (0, _chalk().default)`{bold ${pkg.name}}{cyan @}{${versionColor} ${pkg.version}}`;
  } else {
    return (0, _chalk().default)`{bold ${pkg.name}}`;
  }
}
//# sourceMappingURL=explain.js.map
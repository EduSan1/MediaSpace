{"version":3,"file":"exportAsync.js","names":["promptPublicUrlAsync","value","prompt","type","name","validate","UrlUtils","isHttps","message","CommandError","ensurePublicUrlAsync","url","isDev","program","nonInteractive","isURL","protocols","Log","nestedWarn","exportFilesAsync","projectRoot","options","platforms","platformsFromPlatform","platform","loose","exportOptions","dumpAssetmap","dumpSourcemap","dev","publishOptions","resetCache","clear","target","exportAppAsync","publicUrl","assetUrl","outputDir","experimentalBundle","mergeSourceDirectoriresAsync","mergeSrcDirs","length","srcDirs","mergeSrcDir","concat","mergeSrcUrl","join","nested","mergeAppDistributions","collectMergeSourceUrlsAsync","tmpFolder","path","resolve","fs","remove","ensureDir","downloadDecompressPromises","map","uniqFilename","basename","crypto","randomBytes","toString","tmpFolderUncompressed","downloadAndDecompressAsync","push","Promise","all","actionAsync","warnAboutLocalCLI","localCmd","outputPath","CreateApp","assertFolderEmptyAsync","folderName","overwrite","log"],"sources":["../../../src/commands/export/exportAsync.ts"],"sourcesContent":["import type { ProjectTarget } from '@expo/config';\nimport program from 'commander';\nimport crypto from 'crypto';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { UrlUtils } from 'xdl';\n\nimport CommandError from '../../CommandError';\nimport Log from '../../log';\nimport { warnAboutLocalCLI } from '../../utils/migration';\nimport prompt from '../../utils/prompts';\nimport { platformsFromPlatform } from '../eject/platformOptions';\nimport * as CreateApp from '../utils/CreateApp';\nimport { downloadAndDecompressAsync } from '../utils/Tar';\nimport { exportAppAsync } from './exportAppAsync';\nimport { mergeAppDistributions } from './mergeAppDistributions';\n\ntype Options = {\n  outputDir: string;\n  assetUrl: string;\n  publicUrl?: string;\n  mergeSrcUrl: string[];\n  mergeSrcDir: string[];\n  dev: boolean;\n  clear: boolean;\n  quiet: boolean;\n  platform: string;\n  target?: ProjectTarget;\n  dumpAssetmap: boolean;\n  dumpSourcemap: boolean;\n  maxWorkers?: number;\n  experimentalBundle: boolean;\n};\n\nexport async function promptPublicUrlAsync(): Promise<string> {\n  try {\n    const { value } = await prompt({\n      type: 'text',\n      name: 'value',\n      validate: UrlUtils.isHttps,\n      message: `What is the public url that will host the static files?`,\n    });\n    return value;\n  } catch {\n    throw new CommandError('MISSING_PUBLIC_URL', 'Missing required option: --public-url');\n  }\n}\n\nexport async function ensurePublicUrlAsync(url: any, isDev?: boolean): Promise<string> {\n  if (!url) {\n    if (program.nonInteractive) {\n      throw new CommandError('MISSING_PUBLIC_URL', 'Missing required option: --public-url');\n    }\n    url = await promptPublicUrlAsync();\n  }\n\n  // If we are not in dev mode, ensure that url is https\n  if (!isDev && !UrlUtils.isHttps(url)) {\n    throw new CommandError('INVALID_PUBLIC_URL', '--public-url must be a valid HTTPS URL.');\n  } else if (!UrlUtils.isURL(url, { protocols: ['http', 'https'] })) {\n    Log.nestedWarn(\n      `Dev Mode: --public-url ${url} does not conform to the required HTTP(S) protocol.`\n    );\n  }\n\n  return url;\n}\n\n// TODO: We shouldn't need to wrap a method that is only used for one purpose.\nasync function exportFilesAsync(\n  projectRoot: string,\n  options: Pick<\n    Options,\n    | 'dumpAssetmap'\n    | 'dumpSourcemap'\n    | 'dev'\n    | 'clear'\n    | 'target'\n    | 'outputDir'\n    | 'publicUrl'\n    | 'platform'\n    | 'assetUrl'\n    | 'experimentalBundle'\n  >\n) {\n  const platforms = platformsFromPlatform(options.platform, { loose: true });\n\n  // Make outputDir an absolute path if it isnt already\n  const exportOptions = {\n    dumpAssetmap: options.dumpAssetmap,\n    dumpSourcemap: options.dumpSourcemap,\n    isDev: options.dev,\n    platforms,\n    publishOptions: {\n      resetCache: !!options.clear,\n      target: options.target,\n    },\n  };\n  return await exportAppAsync(\n    projectRoot,\n    options.publicUrl!,\n    options.assetUrl,\n    options.outputDir,\n    exportOptions,\n    options.experimentalBundle\n  );\n}\n\nasync function mergeSourceDirectoriresAsync(\n  projectRoot: string,\n  mergeSrcDirs: string[],\n  options: Pick<Options, 'mergeSrcUrl' | 'mergeSrcDir' | 'outputDir'>\n): Promise<void> {\n  if (!mergeSrcDirs.length) {\n    return;\n  }\n  const srcDirs = options.mergeSrcDir.concat(options.mergeSrcUrl).join(' ');\n  Log.nested(`Starting project merge of ${srcDirs} into ${options.outputDir}`);\n\n  // Merge app distributions\n  await mergeAppDistributions(\n    projectRoot,\n    [...mergeSrcDirs, options.outputDir], // merge stuff in srcDirs and outputDir together\n    options.outputDir\n  );\n  Log.nested(\n    `Project merge was successful. Your merged files can be found in ${options.outputDir}`\n  );\n}\n\nexport async function collectMergeSourceUrlsAsync(\n  projectRoot: string,\n  mergeSrcUrl: string[]\n): Promise<string[]> {\n  // Merge src dirs/urls into a multimanifest if specified\n  const mergeSrcDirs: string[] = [];\n\n  // src urls were specified to merge in, so download and decompress them\n  if (mergeSrcUrl.length > 0) {\n    // delete .tmp if it exists and recreate it anew\n    const tmpFolder = path.resolve(projectRoot, '.tmp');\n    await fs.remove(tmpFolder);\n    await fs.ensureDir(tmpFolder);\n\n    // Download the urls into a tmp dir\n    const downloadDecompressPromises = mergeSrcUrl.map(\n      async (url: string): Promise<void> => {\n        // Add the absolute paths to srcDir\n        const uniqFilename = `${path.basename(url, '.tar.gz')}_${crypto\n          .randomBytes(16)\n          .toString('hex')}`;\n\n        const tmpFolderUncompressed = path.resolve(tmpFolder, uniqFilename);\n        await fs.ensureDir(tmpFolderUncompressed);\n        await downloadAndDecompressAsync(url, tmpFolderUncompressed);\n        // add the decompressed folder to be merged\n        mergeSrcDirs.push(tmpFolderUncompressed);\n      }\n    );\n\n    await Promise.all(downloadDecompressPromises);\n  }\n  return mergeSrcDirs;\n}\n\nexport async function actionAsync(projectRoot: string, options: Options) {\n  warnAboutLocalCLI(projectRoot, { localCmd: 'export' });\n\n  if (!options.experimentalBundle) {\n    // Ensure URL\n    options.publicUrl = await ensurePublicUrlAsync(options.publicUrl, options.dev);\n  }\n\n  // Ensure the output directory is created\n  const outputPath = path.resolve(projectRoot, options.outputDir);\n  await fs.ensureDir(outputPath);\n\n  await CreateApp.assertFolderEmptyAsync({\n    projectRoot: outputPath,\n    folderName: options.outputDir,\n    // Always overwrite files, this is inline with most bundler tooling.\n    overwrite: true,\n  });\n\n  // Wrap the XDL method for exporting assets\n  await exportFilesAsync(projectRoot, options);\n\n  // Merge src dirs/urls into a multimanifest if specified\n  const mergeSrcDirs: string[] = await collectMergeSourceUrlsAsync(\n    projectRoot,\n    options.mergeSrcUrl\n  );\n  // add any local src dirs to be merged\n  mergeSrcDirs.push(...options.mergeSrcDir);\n\n  await mergeSourceDirectoriresAsync(projectRoot, mergeSrcDirs, options);\n\n  Log.log(`Export was successful. Your exported files can be found in ${options.outputDir}`);\n}\n"],"mappings":"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"}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGeneratedHeaderComment = createGeneratedHeaderComment;
exports.createGitIgnoreHash = createGitIgnoreHash;
exports.generatedFooterComment = void 0;
exports.getSanitizedGitIgnoreLines = getSanitizedGitIgnoreLines;
exports.mergeGitIgnoreContents = mergeGitIgnoreContents;
exports.mergeGitIgnorePaths = mergeGitIgnorePaths;
exports.removeGeneratedGitIgnoreContents = removeGeneratedGitIgnoreContents;

function _crypto() {
  const data = _interopRequireDefault(require("crypto"));

  _crypto = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Merge two gitignore files together and add a generated header.
 *
 * @param targetGitIgnorePath
 * @param sourceGitIgnorePath
 */
function mergeGitIgnorePaths(targetGitIgnorePath, sourceGitIgnorePath) {
  if (!_fsExtra().default.existsSync(targetGitIgnorePath)) {
    // No gitignore in the project already, no need to merge anything into anything. I guess they
    // are not using git :O
    return null;
  }

  if (!_fsExtra().default.existsSync(sourceGitIgnorePath)) {
    // Maybe we don't have a gitignore in the template project
    return null;
  }

  const targetGitIgnore = _fsExtra().default.readFileSync(targetGitIgnorePath).toString();

  const sourceGitIgnore = _fsExtra().default.readFileSync(sourceGitIgnorePath).toString();

  const merged = mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore); // Only rewrite the file if it was modified.

  if (merged.contents) {
    _fsExtra().default.writeFileSync(targetGitIgnorePath, merged.contents);
  }

  return merged;
}

const generatedHeaderPrefix = `# @generated expo-cli`;
const generatedFooterComment = `# @end expo-cli`;
/**
 * Get line indexes for the generated section of a gitignore.
 *
 * @param gitIgnore
 */

exports.generatedFooterComment = generatedFooterComment;

function getGeneratedSectionIndexes(gitIgnore) {
  const contents = gitIgnore.split('\n');
  const start = contents.findIndex(line => line.startsWith(generatedHeaderPrefix));
  const end = contents.findIndex(line => line.startsWith(generatedFooterComment));
  return {
    contents,
    start,
    end
  };
}
/**
 * Removes the generated section from a gitignore, returns null when nothing can be removed.
 * This sways heavily towards not removing lines unless it's certain that modifications were not made to the gitignore manually.
 *
 * @param gitIgnore
 */


function removeGeneratedGitIgnoreContents(gitIgnore) {
  const {
    contents,
    start,
    end
  } = getGeneratedSectionIndexes(gitIgnore);

  if (start > -1 && end > -1 && start < end) {
    contents.splice(start, end - start + 1); // TODO: We could in theory check that the contents we're removing match the hash used in the header,
    // this would ensure that we don't accidentally remove lines that someone added or removed from the generated section.

    return contents.join('\n');
  }

  return null;
}
/**
 * Merge the contents of two gitignores together and add a generated header.
 *
 * @param targetGitIgnore contents of the existing gitignore
 * @param sourceGitIgnore contents of the extra gitignore
 */


function mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore) {
  const header = createGeneratedHeaderComment(sourceGitIgnore);

  if (!targetGitIgnore.includes(header)) {
    // Ensure the old generated gitignore contents are removed.
    const sanitizedTarget = removeGeneratedGitIgnoreContents(targetGitIgnore);
    return {
      contents: [sanitizedTarget !== null && sanitizedTarget !== void 0 ? sanitizedTarget : targetGitIgnore, header, `# The following patterns were generated by expo-cli`, ``, sourceGitIgnore, generatedFooterComment].join('\n'),
      didMerge: true,
      didClear: !!sanitizedTarget
    };
  }

  return {
    contents: targetGitIgnore,
    didClear: false,
    didMerge: false
  };
}

function createGeneratedHeaderComment(gitIgnore) {
  const hashKey = createGitIgnoreHash(getSanitizedGitIgnoreLines(gitIgnore).join('\n'));
  return `${generatedHeaderPrefix} ${hashKey}`;
}
/**
 * Normalize the contents of a gitignore to ensure that minor changes like new lines or sort order don't cause a regeneration.
 */


function getSanitizedGitIgnoreLines(gitIgnore) {
  // filter, trim, and sort the lines.
  return gitIgnore.split('\n').filter(v => {
    const line = v.trim(); // Strip comments

    if (line.startsWith('#')) {
      return false;
    }

    return !!line;
  }).sort();
}

function createGitIgnoreHash(gitIgnore) {
  // this doesn't need to be secure, the shorter the better.
  const hash = _crypto().default.createHash('sha1').update(gitIgnore).digest('hex');

  return `sync-${hash}`;
}
//# sourceMappingURL=GitIgnore.js.map
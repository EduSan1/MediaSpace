"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureBundleIdentifierAsync = configureBundleIdentifierAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _configPlugins() {
  const data = require("@expo/config-plugins");

  _configPlugins = function () {
    return data;
  };

  return data;
}

function _jsonFile() {
  const data = _interopRequireDefault(require("@expo/json-file"));

  _jsonFile = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _prompts() {
  const data = require("prompts");

  _prompts = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("./internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * BundleIdentifier.ts
 *
 * NOTE:
 * The code in this module originates from eas-cli and the canonical version of
 * it is in
 * https://github.com/expo/eas-cli/blob/6a0a9bbaaad03b053b5930f7d14bde35b4d0a9f0/packages/eas-cli/src/build/ios/bundleIdentifer.ts#L36
 * Any changes to this code should be applied to eas-cli as well!
 *
 * TODO: move the code for configuring and validating the bundle identifier
 * to a shared package that can be used for both eas-cli and expo-cli.
 */
const {
  logInfo,
  logWarning
} = _internal().ProjectUtils;

var BundleIdentiferSource;

(function (BundleIdentiferSource) {
  BundleIdentiferSource[BundleIdentiferSource["XcodeProject"] = 0] = "XcodeProject";
  BundleIdentiferSource[BundleIdentiferSource["AppJson"] = 1] = "AppJson";
})(BundleIdentiferSource || (BundleIdentiferSource = {}));

async function configureBundleIdentifierAsync(projectRoot, exp) {
  const configDescription = (0, _config().getProjectConfigDescription)(projectRoot);

  const bundleIdentifierFromPbxproj = _configPlugins().IOSConfig.BundleIdentifier.getBundleIdentifierFromPbxproj(projectRoot);

  const bundleIdentifierFromConfig = _configPlugins().IOSConfig.BundleIdentifier.getBundleIdentifier(exp);

  if (bundleIdentifierFromPbxproj && bundleIdentifierFromConfig) {
    if (bundleIdentifierFromPbxproj === bundleIdentifierFromConfig) {
      return bundleIdentifierFromConfig;
    } else {
      logWarning(projectRoot, 'expo', `We detected that your Xcode project is configured with a different bundle identifier than the one defined in ${configDescription}.`);
      const hasBundleIdentifierInStaticConfig = await hasBundleIdentifierInStaticConfigAsync(projectRoot, exp);

      if (!hasBundleIdentifierInStaticConfig) {
        logInfo(projectRoot, 'expo', `If you choose the one defined in ${configDescription} we'll automatically configure your Xcode project with it.
However, if you choose the one defined in the Xcode project you'll have to update ${configDescription} on your own.`);
      }

      const {
        bundleIdentifierSource
      } = await (0, _prompts().prompt)({
        type: 'select',
        name: 'bundleIdentifierSource',
        message: 'Which bundle identifier should we use?',
        choices: [{
          title: `${_chalk().default.bold(bundleIdentifierFromPbxproj)} - In Xcode project`,
          value: BundleIdentiferSource.XcodeProject
        }, {
          title: `${_chalk().default.bold(bundleIdentifierFromConfig)} - In your ${configDescription}`,
          value: BundleIdentiferSource.AppJson
        }]
      });

      if (bundleIdentifierSource === BundleIdentiferSource.AppJson) {
        _configPlugins().IOSConfig.BundleIdentifier.setBundleIdentifierForPbxproj(projectRoot, bundleIdentifierFromConfig);

        return bundleIdentifierFromConfig;
      } else {
        if (hasBundleIdentifierInStaticConfig) {
          await updateAppJsonConfigAsync(projectRoot, exp, bundleIdentifierFromPbxproj);
        } else {
          throw new Error(missingBundleIdentifierMessage(configDescription));
        }

        return bundleIdentifierFromPbxproj;
      }
    }
  } else if (bundleIdentifierFromPbxproj && !bundleIdentifierFromConfig) {
    if ((0, _config().getConfigFilePaths)(projectRoot).staticConfigPath) {
      await updateAppJsonConfigAsync(projectRoot, exp, bundleIdentifierFromPbxproj);
    }

    return bundleIdentifierFromPbxproj;
  } else if (!bundleIdentifierFromPbxproj && bundleIdentifierFromConfig) {
    _configPlugins().IOSConfig.BundleIdentifier.setBundleIdentifierForPbxproj(projectRoot, bundleIdentifierFromConfig);

    return bundleIdentifierFromConfig;
  } else {
    throw new Error(missingBundleIdentifierMessage(configDescription));
  }
}

function missingBundleIdentifierMessage(configDescription) {
  return `Please define "ios.bundleIdentifier" in ${configDescription}.`;
}

async function updateAppJsonConfigAsync(projectRoot, exp, newBundleIdentifier) {
  var _rawStaticConfig$expo;

  const paths = (0, _config().getConfigFilePaths)(projectRoot);
  (0, _assert().default)(paths.staticConfigPath, "Can't update dynamic configs");
  const rawStaticConfig = await _jsonFile().default.readAsync(paths.staticConfigPath);
  rawStaticConfig.expo = { ...rawStaticConfig.expo,
    ios: { ...((_rawStaticConfig$expo = rawStaticConfig.expo) === null || _rawStaticConfig$expo === void 0 ? void 0 : _rawStaticConfig$expo.ios),
      bundleIdentifier: newBundleIdentifier
    }
  };
  await _jsonFile().default.writeAsync(paths.staticConfigPath, rawStaticConfig);
  exp.ios = { ...exp.ios,
    bundleIdentifier: newBundleIdentifier
  };
}
/**
 * Check if static config exists and if ios.bundleIdentifier is defined there.
 * It will return false if the value in static config is different than "ios.bundleIdentifier" in ExpoConfig
 */


async function hasBundleIdentifierInStaticConfigAsync(projectRoot, exp) {
  var _exp$ios, _rawStaticConfig$expo2, _rawStaticConfig$expo3;

  if (!((_exp$ios = exp.ios) !== null && _exp$ios !== void 0 && _exp$ios.bundleIdentifier)) {
    return false;
  }

  const paths = (0, _config().getConfigFilePaths)(projectRoot);

  if (!paths.staticConfigPath) {
    return false;
  }

  const rawStaticConfig = _jsonFile().default.read(paths.staticConfigPath);

  return (rawStaticConfig === null || rawStaticConfig === void 0 ? void 0 : (_rawStaticConfig$expo2 = rawStaticConfig.expo) === null || _rawStaticConfig$expo2 === void 0 ? void 0 : (_rawStaticConfig$expo3 = _rawStaticConfig$expo2.ios) === null || _rawStaticConfig$expo3 === void 0 ? void 0 : _rawStaticConfig$expo3.bundleIdentifier) === exp.ios.bundleIdentifier;
}
//# sourceMappingURL=BundleIdentifier.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.choosePortAsync = choosePortAsync;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _freeportAsync() {
  const data = _interopRequireDefault(require("freeport-async"));

  _freeportAsync = function () {
    return data;
  };

  return data;
}

function _isRoot() {
  const data = _interopRequireDefault(require("is-root"));

  _isRoot = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("../Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _Prompts() {
  const data = require("../Prompts");

  _Prompts = function () {
    return data;
  };

  return data;
}

function _getRunningProcess() {
  const data = require("./getRunningProcess");

  _getRunningProcess = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function choosePortAsync(projectRoot, {
  defaultPort,
  host,
  reuseExistingPort
}) {
  try {
    const port = await (0, _freeportAsync().default)(defaultPort, {
      hostnames: [host !== null && host !== void 0 ? host : null]
    });

    if (port === defaultPort) {
      return port;
    }

    const isRestricted = process.platform !== 'win32' && defaultPort < 1024 && !(0, _isRoot().default)();
    let message = isRestricted ? `Admin permissions are required to run a server on a port below 1024` : `Port ${_chalk().default.bold(defaultPort)} is`;
    const runningProcess = isRestricted ? null : (0, _getRunningProcess().getRunningProcess)(defaultPort);

    if (runningProcess) {
      const pidTag = _chalk().default.gray(`(pid ${runningProcess.pid})`);

      if (runningProcess.directory === projectRoot) {
        message += ` running this app in another window`;

        if (reuseExistingPort) {
          return null;
        }
      } else {
        message += ` running ${_chalk().default.cyan(runningProcess.command)} in another window`;
      }

      message += '\n' + _chalk().default.gray(`  ${runningProcess.directory} ${pidTag}`);
    }

    _Logger().default.global.info(`\u203A ${message}`);

    const change = await (0, _Prompts().confirmAsync)({
      message: `Use port ${port} instead?`,
      initial: true
    });
    return change ? port : null;
  } catch (error) {
    if (error.code === 'ABORTED') {
      throw error;
    } else if (error.code === 'NON_INTERACTIVE') {
      _Logger().default.global.warn(error.message);

      return null;
    }

    throw error;
  }
}
//# sourceMappingURL=choosePortAsync.js.map
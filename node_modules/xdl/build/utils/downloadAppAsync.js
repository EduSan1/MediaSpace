"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.downloadAppAsync = downloadAppAsync;

function _axios() {
  const data = _interopRequireDefault(require("axios"));

  _axios = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TIMER_DURATION = 30000;
const TIMEOUT = 3600000;

async function _downloadAsync(url, outputPath, progressFunction, retryFunction) {
  let promptShown = false;
  let currentProgress = 0;

  const {
    cancel,
    token
  } = _axios().default.CancelToken.source();

  let warningTimer = setTimeout(() => {
    if (retryFunction) {
      retryFunction(cancel);
    }

    promptShown = true;
  }, TIMER_DURATION);
  const tmpPath = `${outputPath}.download`;
  const config = {
    timeout: TIMEOUT,
    responseType: 'stream',
    cancelToken: token
  };
  const response = await (0, _axios().default)(url, config);
  await new Promise(resolve => {
    const totalDownloadSize = response.data.headers['content-length'];
    let downloadProgress = 0;
    response.data.on('data', chunk => {
      downloadProgress += chunk.length;
      const roundedProgress = Math.floor(downloadProgress / totalDownloadSize * 100);

      if (currentProgress !== roundedProgress) {
        currentProgress = roundedProgress;
        clearTimeout(warningTimer);

        if (!promptShown) {
          warningTimer = setTimeout(() => {
            if (retryFunction) {
              retryFunction(cancel);
            }

            promptShown = true;
          }, TIMER_DURATION);
        }

        if (progressFunction) {
          progressFunction(roundedProgress);
        }
      }
    }).on('end', () => {
      clearTimeout(warningTimer);

      if (progressFunction && currentProgress !== 100) {
        progressFunction(100);
      }

      resolve();
    }).pipe(_fsExtra().default.createWriteStream(tmpPath));
  });
  await _fsExtra().default.rename(tmpPath, outputPath);
}

async function downloadAppAsync(url, outputPath, {
  extract = false
} = {}, progressFunction, retryFunction) {
  if (extract) {
    const dotExpoHomeDirectory = _internal().UserSettings.dotExpoHomeDirectory();

    const tmpPath = _path().default.join(dotExpoHomeDirectory, 'tmp-download-file');

    await _downloadAsync(url, tmpPath, progressFunction);
    await _internal().Extract.extractAsync(tmpPath, outputPath);

    _fsExtra().default.removeSync(tmpPath);
  } else {
    await _downloadAsync(url, outputPath, progressFunction, retryFunction);
  }
}
//# sourceMappingURL=downloadAppAsync.js.map
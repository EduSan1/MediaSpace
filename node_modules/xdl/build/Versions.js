"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;
exports.gteSdkVersion = gteSdkVersion;
exports.lteSdkVersion = lteSdkVersion;
exports.newestReleasedSdkVersionAsync = newestReleasedSdkVersionAsync;
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
exports.releasedSdkVersionsAsync = releasedSdkVersionsAsync;
exports.sdkVersionsAsync = sdkVersionsAsync;
exports.versionsAsync = versionsAsync;

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _pickBy() {
  const data = _interopRequireDefault(require("lodash/pickBy"));

  _pickBy = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("./internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function versionsAsync(options) {
  const api = new (_internal().ApiV2)();
  const versionCache = new (_internal().FsCache.Cacher)(() => api.getAsync('versions/latest'), 'versions.json', 0, _path().default.join(__dirname, '../caches/versions.json')); // Clear cache when opting in to beta because things can change quickly in beta

  if (_getenv().default.boolish('EXPO_BETA', false) || options !== null && options !== void 0 && options.skipCache) {
    versionCache.clearAsync();
  }

  return await versionCache.getAsync();
}

async function sdkVersionsAsync() {
  const {
    sdkVersions
  } = await versionsAsync();
  return sdkVersions;
} // NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we only want to list out released
// versions


async function releasedSdkVersionsAsync() {
  const sdkVersions = await sdkVersionsAsync();
  return (0, _pickBy().default)(sdkVersions, (data, _sdkVersionString) => !!data.releaseNoteUrl || _getenv().default.boolish('EXPO_BETA', false) && data.beta);
}

function gteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return true;
  }

  try {
    return _semver().default.gte(expJson.sdkVersion, sdkVersion);
  } catch {
    throw new (_internal().XDLError)('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function lteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return false;
  }

  try {
    return _semver().default.lte(expJson.sdkVersion, sdkVersion);
  } catch {
    throw new (_internal().XDLError)('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function parseSdkVersionFromTag(tag) {
  if (tag.startsWith('sdk-')) {
    return tag.substring(4);
  }

  return tag;
} // NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we need to get the latest *released*
// version, not just the latest version.


async function newestReleasedSdkVersionAsync() {
  const betaOptInEnabled = _getenv().default.boolish('EXPO_BETA', false);

  const sdkVersions = await sdkVersionsAsync();
  let result = null;
  let highestMajorVersion = '0.0.0';

  for (const [version, data] of Object.entries(sdkVersions)) {
    const hasReleaseNotes = !!data.releaseNoteUrl;
    const isBeta = !!data.beta;

    if (_semver().default.major(version) > _semver().default.major(highestMajorVersion) && (hasReleaseNotes || isBeta && betaOptInEnabled)) {
      highestMajorVersion = version;
      result = data;
    }
  }

  return {
    version: highestMajorVersion,
    data: result
  };
}

async function oldestSupportedMajorVersionAsync() {
  const sdkVersions = await sdkVersionsAsync();
  const supportedVersions = (0, _pickBy().default)(sdkVersions, v => !v.isDeprecated);
  const versionNumbers = Object.keys(supportedVersions).map(version => _semver().default.major(version));
  return Math.min(...versionNumbers);
}

async function canTurtleBuildSdkVersion(sdkVersion, platform) {
  var _supportedVersions$pl;

  if (sdkVersion === 'UNVERSIONED') {
    return true;
  }

  if (_semver().default.valid(sdkVersion) == null) {
    throw new (_internal().XDLError)('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
  }

  const supportedVersions = await getSdkVersionsSupportedByTurtle();
  const supportedVersionsForPlatform = (_supportedVersions$pl = supportedVersions[platform]) !== null && _supportedVersions$pl !== void 0 ? _supportedVersions$pl : [];
  return supportedVersionsForPlatform.indexOf(sdkVersion) !== -1;
}

async function getSdkVersionsSupportedByTurtle() {
  const api = new (_internal().ApiV2)();
  return await api.getAsync('standalone-build/supportedSDKVersions');
}
//# sourceMappingURL=Versions.js.map
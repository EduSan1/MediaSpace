"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OSX_SOURCE_PATH = void 0;
exports.addToPathAsync = addToPathAsync;
exports.getBinariesPath = getBinariesPath;
exports.isXcodeInstalled = isXcodeInstalled;
exports.writePathToUserSettingsAsync = writePathToUserSettingsAsync;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _hasbin() {
  const data = _interopRequireDefault(require("hasbin"));

  _hasbin = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("./internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const OSX_SOURCE_PATH = _path().default.join(__dirname, '..', 'binaries', 'osx');

exports.OSX_SOURCE_PATH = OSX_SOURCE_PATH;

function _hasbinAsync(name) {
  return new Promise((resolve, reject) => {
    (0, _hasbin().default)(name, result => {
      resolve(result);
    });
  });
}

function getBinariesPath() {
  if (process.platform === 'darwin') {
    return _path().default.join(__dirname, '..', 'binaries', 'osx');
  } else if (process.platform === 'win32') {
    return _path().default.join(__dirname, '..', 'binaries', 'windows');
  } else if (process.platform === 'linux') {
    return _path().default.join(__dirname, '..', 'binaries', 'linux');
  } else {
    throw new (_internal().XDLError)('PLATFORM_NOT_SUPPORTED', 'Platform not supported.');
  }
}

async function addToPathAsync(name) {
  if (await _hasbinAsync(name)) {
    return;
  } // Users can set {ignoreBundledBinaries: ["watchman"]} to tell us to never use our version


  const ignoreBundledBinaries = await _internal().UserSettings.getAsync('ignoreBundledBinaries', []);

  if (ignoreBundledBinaries.includes(name)) {
    return;
  }

  const binariesPath = _path().default.join(getBinariesPath(), name);

  _prependToPath(binariesPath);
}

function _prependToPath(newPath) {
  let currentPath = process.env.PATH ? process.env.PATH : '';

  if (currentPath.length > 0) {
    const delimiter = process.platform === 'win32' ? ';' : ':';
    currentPath = `${delimiter}${currentPath}`;
  }

  process.env.PATH = `${newPath}${currentPath}`;
}

async function writePathToUserSettingsAsync() {
  await _internal().UserSettings.setAsync('PATH', process.env.PATH); // Used in detach app

  const pathFile = _path().default.join(_internal().UserSettings.dotExpoHomeDirectory(), 'PATH');

  await _fsExtra().default.writeFile(pathFile, process.env.PATH);
}

function _isDirectory(dir) {
  try {
    if (_fsExtra().default.statSync(dir).isDirectory()) {
      return true;
    }

    return false;
  } catch {
    return false;
  }
}

function isXcodeInstalled() {
  return _isDirectory('/Applications/Xcode.app/');
}
//# sourceMappingURL=Binaries.js.map
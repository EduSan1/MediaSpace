"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureSimulatorAppRunningAsync = ensureSimulatorAppRunningAsync;
exports.isSimulatorAppRunningAsync = isSimulatorAppRunningAsync;
exports.killAllAsync = killAllAsync;
exports.openSimulatorAppAsync = openSimulatorAppAsync;
exports.waitForSimulatorAppToStart = waitForSimulatorAppToStart;

function osascript() {
  const data = _interopRequireWildcard(require("@expo/osascript"));

  osascript = function () {
    return data;
  };

  return data;
}

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _child_process() {
  const data = require("child_process");

  _child_process = function () {
    return data;
  };

  return data;
}

function _util() {
  const data = require("util");

  _util = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _waitForActionAsync() {
  const data = require("./waitForActionAsync");

  _waitForActionAsync = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const execAsync = (0, _util().promisify)(_child_process().exec);

async function waitForSimulatorAppToStart() {
  return (0, _waitForActionAsync().waitForActionAsync)({
    interval: 50,
    action: isSimulatorAppRunningAsync
  });
}
/**
 * I think the app can be open while no simulators are booted.
 */


async function isSimulatorAppRunningAsync() {
  try {
    const zeroMeansNo = (await osascript().execAsync('tell app "System Events" to count processes whose name is "Simulator"')).trim();

    if (zeroMeansNo === '0') {
      return false;
    }
  } catch (error) {
    if (error.message.includes('Application isnâ€™t running')) {
      return false;
    }

    throw error;
  }

  return true;
}

async function ensureSimulatorAppRunningAsync({
  udid
}) {
  // Yes, simulators can be booted even if the app isn't running, obviously we'd never want this.
  if (!(await isSimulatorAppRunningAsync())) {
    _internal().Logger.global.info(`\u203A Opening the iOS simulator, this might take a moment.`); // In theory this would ensure the correct simulator is booted as well.
    // This isn't theory though, this is Xcode.


    await openSimulatorAppAsync({
      udid
    });

    if (!(await waitForSimulatorAppToStart())) {
      throw new (_waitForActionAsync().TimeoutError)(`Simulator app did not open fast enough. Try opening Simulator first, then running your app.`);
    }
  }
}

async function openSimulatorAppAsync({
  udid
}) {
  const args = ['open', '-a', 'Simulator'];

  if (udid) {
    // This has no effect if the app is already running.
    args.push('--args', '-CurrentDeviceUDID', udid);
  }

  await execAsync(args.join(' '));
}

async function killAllAsync() {
  return await (0, _spawnAsync().default)('killAll', ['Simulator']);
}
//# sourceMappingURL=ensureSimulatorAppRunningAsync.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClientManager = void 0;

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function tls() {
  const data = _interopRequireWildcard(require("tls"));

  tls = function () {
    return data;
  };

  return data;
}

function _afc() {
  const data = require("./client/afc");

  _afc = function () {
    return data;
  };

  return data;
}

function _debugserver() {
  const data = require("./client/debugserver");

  _debugserver = function () {
    return data;
  };

  return data;
}

function _installation_proxy() {
  const data = require("./client/installation_proxy");

  _installation_proxy = function () {
    return data;
  };

  return data;
}

function _lockdownd() {
  const data = require("./client/lockdownd");

  _lockdownd = function () {
    return data;
  };

  return data;
}

function _mobile_image_mounter() {
  const data = require("./client/mobile_image_mounter");

  _mobile_image_mounter = function () {
    return data;
  };

  return data;
}

function _usbmuxd() {
  const data = require("./client/usbmuxd");

  _usbmuxd = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ClientManager {
  constructor(pairRecord, device, lockdowndClient) {
    this.pairRecord = pairRecord;
    this.device = device;
    this.lockdowndClient = lockdowndClient;

    _defineProperty(this, "connections", void 0);

    this.connections = [lockdowndClient.socket];
  }

  static async create(udid) {
    const usbmuxClient = new (_usbmuxd().UsbmuxdClient)(_usbmuxd().UsbmuxdClient.connectUsbmuxdSocket());
    const device = await usbmuxClient.getDevice(udid);
    const pairRecord = await usbmuxClient.readPairRecord(device.Properties.SerialNumber);
    const lockdownSocket = await usbmuxClient.connect(device, 62078);
    const lockdownClient = new (_lockdownd().LockdowndClient)(lockdownSocket);
    await lockdownClient.doHandshake(pairRecord);
    return new ClientManager(pairRecord, device, lockdownClient);
  }

  async getUsbmuxdClient() {
    const usbmuxClient = new (_usbmuxd().UsbmuxdClient)(_usbmuxd().UsbmuxdClient.connectUsbmuxdSocket());
    this.connections.push(usbmuxClient.socket);
    return usbmuxClient;
  }

  async getLockdowndClient() {
    const usbmuxClient = new (_usbmuxd().UsbmuxdClient)(_usbmuxd().UsbmuxdClient.connectUsbmuxdSocket());
    const lockdownSocket = await usbmuxClient.connect(this.device, 62078);
    const lockdownClient = new (_lockdownd().LockdowndClient)(lockdownSocket);
    this.connections.push(lockdownClient.socket);
    return lockdownClient;
  }

  async getLockdowndClientWithHandshake() {
    const lockdownClient = await this.getLockdowndClient();
    await lockdownClient.doHandshake(this.pairRecord);
    return lockdownClient;
  }

  async getAFCClient() {
    return this.getServiceClient('com.apple.afc', _afc().AFCClient);
  }

  async getInstallationProxyClient() {
    return this.getServiceClient('com.apple.mobile.installation_proxy', _installation_proxy().InstallationProxyClient);
  }

  async getMobileImageMounterClient() {
    return this.getServiceClient('com.apple.mobile.mobile_image_mounter', _mobile_image_mounter().MobileImageMounterClient);
  }

  async getDebugserverClient() {
    try {
      // iOS 14 added support for a secure debug service so try to connect to that first
      return await this.getServiceClient('com.apple.debugserver.DVTSecureSocketProxy', _debugserver().DebugserverClient);
    } catch {
      // otherwise, fall back to the previous implementation
      return this.getServiceClient('com.apple.debugserver', _debugserver().DebugserverClient, true);
    }
  }

  async getServiceClient(name, ServiceType, disableSSL = false) {
    const {
      port: servicePort,
      enableServiceSSL
    } = await this.lockdowndClient.startService(name);
    const usbmuxClient = new (_usbmuxd().UsbmuxdClient)(_usbmuxd().UsbmuxdClient.connectUsbmuxdSocket());
    let usbmuxdSocket = await usbmuxClient.connect(this.device, servicePort);

    if (enableServiceSSL) {
      const tlsOptions = {
        rejectUnauthorized: false,
        secureContext: tls().createSecureContext({
          secureProtocol: 'TLSv1_method',
          cert: this.pairRecord.RootCertificate,
          key: this.pairRecord.RootPrivateKey
        })
      }; // Some services seem to not support TLS/SSL after the initial handshake
      // More info: https://github.com/libimobiledevice/libimobiledevice/issues/793

      if (disableSSL) {
        // According to https://nodejs.org/api/tls.html#tls_tls_connect_options_callback we can
        // pass any Duplex in to tls.connect instead of a Socket. So we'll use our proxy to keep
        // the TLS wrapper and underlying usbmuxd socket separate.
        const proxy = new UsbmuxdProxy(usbmuxdSocket);
        tlsOptions.socket = proxy;
        await new Promise((resolve, reject) => {
          const timeoutId = setTimeout(() => {
            reject(new Error('The TLS handshake failed to complete after 5s.'));
          }, 5000);
          tls().connect(tlsOptions, function () {
            clearTimeout(timeoutId); // After the handshake, we don't need TLS or the proxy anymore,
            // since we'll just pass in the naked usbmuxd socket to the service client

            this.destroy();
            resolve();
          });
        });
      } else {
        tlsOptions.socket = usbmuxdSocket;
        usbmuxdSocket = tls().connect(tlsOptions);
      }
    }

    const client = new ServiceType(usbmuxdSocket);
    this.connections.push(client.socket);
    return client;
  }

  end() {
    for (const socket of this.connections) {
      // may already be closed
      try {
        socket.end();
      } catch {// ignore
      }
    }
  }

}

exports.ClientManager = ClientManager;

class UsbmuxdProxy extends _stream().Duplex {
  constructor(usbmuxdSock) {
    super();
    this.usbmuxdSock = usbmuxdSock;
    this.usbmuxdSock.on('data', data => {
      this.push(data);
    });
  }

  _write(chunk, encoding, callback) {
    this.usbmuxdSock.write(chunk);
    callback();
  }

  _read(size) {// Stub so we don't error, since we push everything we get from usbmuxd as it comes in.
    // TODO: better way to do this?
  }

  _destroy() {
    this.usbmuxdSock.removeAllListeners();
  }

}
//# sourceMappingURL=manager.js.map
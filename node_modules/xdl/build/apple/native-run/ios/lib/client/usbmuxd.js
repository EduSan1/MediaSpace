"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UsbmuxdClient = void 0;

function _plist() {
  const data = _interopRequireDefault(require("@expo/plist"));

  _plist = function () {
    return data;
  };

  return data;
}

function _debug() {
  const data = _interopRequireDefault(require("debug"));

  _debug = function () {
    return data;
  };

  return data;
}

function net() {
  const data = _interopRequireWildcard(require("net"));

  net = function () {
    return data;
  };

  return data;
}

function _parseBinaryPlistAsync() {
  const data = require("../../../../../utils/parseBinaryPlistAsync");

  _parseBinaryPlistAsync = function () {
    return data;
  };

  return data;
}

function _usbmux() {
  const data = require("../protocol/usbmux");

  _usbmux = function () {
    return data;
  };

  return data;
}

function _client() {
  const data = require("./client");

  _client = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2021 Expo, Inc.
 * Copyright (c) 2018 Drifty Co.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const debug = (0, _debug().default)('expo:xdl:ios:lib:client:usbmuxd');

function isUsbmuxdConnectResponse(resp) {
  return resp.MessageType === 'Result' && resp.Number !== undefined;
}

function isUsbmuxdDeviceResponse(resp) {
  return resp.DeviceList !== undefined;
}

function isUsbmuxdPairRecordResponse(resp) {
  return resp.PairRecordData !== undefined;
}

class UsbmuxdClient extends _client().ServiceClient {
  constructor(socket) {
    super(socket, new (_usbmux().UsbmuxProtocolClient)(socket));
    this.socket = socket;
  }

  static connectUsbmuxdSocket() {
    debug('connectUsbmuxdSocket');

    if (process.platform === 'win32') {
      return net().connect({
        port: 27015,
        host: 'localhost'
      });
    } else {
      return net().connect({
        path: '/var/run/usbmuxd'
      });
    }
  }

  async connect(device, port) {
    debug(`connect: ${device.DeviceID} on port ${port}`);
    const resp = await this.protocolClient.sendMessage({
      messageType: 'Connect',
      extraFields: {
        DeviceID: device.DeviceID,
        PortNumber: htons(port)
      }
    });

    if (isUsbmuxdConnectResponse(resp) && resp.Number === 0) {
      return this.protocolClient.socket;
    } else {
      throw new (_client().ResponseError)(`There was an error connecting to ${device.DeviceID} on port ${port}`, resp);
    }
  }

  async getDevices() {
    debug('getDevices');
    const resp = await this.protocolClient.sendMessage({
      messageType: 'ListDevices'
    });

    if (isUsbmuxdDeviceResponse(resp)) {
      return resp.DeviceList;
    } else {
      throw new (_client().ResponseError)('Invalid response from getDevices', resp);
    }
  }

  async getDevice(udid) {
    debug(`getDevice ${udid ? 'udid: ' + udid : ''}`);
    const devices = await this.getDevices();

    if (!devices.length) {
      throw new Error('No devices found');
    }

    if (!udid) {
      return devices[0];
    }

    for (const device of devices) {
      if (device.Properties && device.Properties.SerialNumber === udid) {
        return device;
      }
    }

    throw new Error(`No device with udid ${udid} found`);
  }

  async readPairRecord(udid) {
    debug(`readPairRecord: ${udid}`);
    const resp = await this.protocolClient.sendMessage({
      messageType: 'ReadPairRecord',
      extraFields: {
        PairRecordID: udid
      }
    });

    if (isUsbmuxdPairRecordResponse(resp)) {
      // the pair record can be created as a binary plist
      const BPLIST_MAGIC = Buffer.from('bplist00');

      if (BPLIST_MAGIC.compare(resp.PairRecordData, 0, 8) === 0) {
        debug('Binary plist pair record detected.');
        return (0, _parseBinaryPlistAsync().parsePlistBuffer)(resp.PairRecordData)[0];
      } else {
        // TODO: use parsePlistBuffer
        return _plist().default.parse(resp.PairRecordData.toString()); // TODO: type guard
      }
    } else {
      throw new (_client().ResponseError)(`There was an error reading pair record for udid: ${udid}`, resp);
    }
  }

}

exports.UsbmuxdClient = UsbmuxdClient;

function htons(n) {
  return (n & 0xff) << 8 | n >> 8 & 0xff;
}
//# sourceMappingURL=usbmuxd.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LockdownProtocolWriter = exports.LockdownProtocolReader = exports.LockdownProtocolClient = exports.LOCKDOWN_HEADER_SIZE = void 0;
exports.isLockdownErrorResponse = isLockdownErrorResponse;
exports.isLockdownResponse = isLockdownResponse;

function _plist() {
  const data = _interopRequireDefault(require("@expo/plist"));

  _plist = function () {
    return data;
  };

  return data;
}

function _debug() {
  const data = _interopRequireDefault(require("debug"));

  _debug = function () {
    return data;
  };

  return data;
}

function _libErrors() {
  const data = require("../lib-errors");

  _libErrors = function () {
    return data;
  };

  return data;
}

function _protocol() {
  const data = require("./protocol");

  _protocol = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2021 Expo, Inc.
 * Copyright (c) 2018 Drifty Co.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const debug = (0, _debug().default)('expo:xdl:ios:lib:protocol:lockdown');
const LOCKDOWN_HEADER_SIZE = 4;
exports.LOCKDOWN_HEADER_SIZE = LOCKDOWN_HEADER_SIZE;

function isDefined(val) {
  return typeof val !== 'undefined';
}

function isLockdownResponse(resp) {
  return isDefined(resp.Status);
}

function isLockdownErrorResponse(resp) {
  return isDefined(resp.Error);
}

class LockdownProtocolClient extends _protocol().ProtocolClient {
  constructor(socket) {
    super(socket, new (_protocol().ProtocolReaderFactory)(LockdownProtocolReader), new LockdownProtocolWriter());
  }

}

exports.LockdownProtocolClient = LockdownProtocolClient;

class LockdownProtocolReader extends _protocol().PlistProtocolReader {
  constructor(callback) {
    super(LOCKDOWN_HEADER_SIZE, callback);
  }

  parseHeader(data) {
    return data.readUInt32BE(0);
  }

  parseBody(data) {
    const resp = super.parseBody(data);
    debug(`Response: ${JSON.stringify(resp)}`);

    if (isLockdownErrorResponse(resp)) {
      if (resp.Error === 'DeviceLocked') {
        throw new (_libErrors().IOSLibError)('Device is currently locked.', 'DeviceLocked');
      }

      if (resp.Error === 'InvalidService') {
        let errorMessage = `${resp.Error}: ${resp.Service} (request: ${resp.Request})`;

        if (resp.Service === 'com.apple.debugserver') {
          errorMessage += '\nTry reconnecting your device. You can also debug service logs with `export DEBUG=expo:xdl:ios:*`';
        }

        throw new Error(errorMessage);
      }

      throw new Error(resp.Error);
    }

    return resp;
  }

}

exports.LockdownProtocolReader = LockdownProtocolReader;

class LockdownProtocolWriter {
  write(socket, plistData) {
    debug(`socket write: ${JSON.stringify(plistData)}`);

    const plistMessage = _plist().default.build(plistData);

    const header = Buffer.alloc(LOCKDOWN_HEADER_SIZE);
    header.writeUInt32BE(plistMessage.length, 0);
    socket.write(header);
    socket.write(plistMessage);
  }

}

exports.LockdownProtocolWriter = LockdownProtocolWriter;
//# sourceMappingURL=lockdown.js.map
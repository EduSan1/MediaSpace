{"version":3,"file":"protocol.js","names":["BPLIST_MAGIC","Buffer","from","ProtocolReaderFactory","constructor","ProtocolReader","create","callback","headerSize","alloc","onData","bind","data","buffer","concat","bodyLength","length","parseHeader","slice","parseBody","body","err","PlistProtocolReader","compare","parsePlistBuffer","plist","parse","toString","ProtocolClient","socket","readerFactory","writer","sendMessage","msg","Promise","resolve","reject","reader","resp","value","removeListener","on","write"],"sources":["../../../../../../src/apple/native-run/ios/lib/protocol/protocol.ts"],"sourcesContent":["/**\n * Copyright (c) 2021 Expo, Inc.\n * Copyright (c) 2018 Drifty Co.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport plist from '@expo/plist';\nimport type * as net from 'net';\n\nimport { parsePlistBuffer } from '../../../../../utils/parseBinaryPlistAsync';\n\nconst BPLIST_MAGIC = Buffer.from('bplist00');\n\nexport type ProtocolReaderCallback = (resp: any, err?: Error) => void;\n\nexport class ProtocolReaderFactory<T> {\n  constructor(private ProtocolReader: new (callback: ProtocolReaderCallback) => T) {}\n\n  create(callback: (resp: any, err?: Error) => void): T {\n    return new this.ProtocolReader(callback);\n  }\n}\n\nexport abstract class ProtocolReader {\n  protected body!: Buffer; // TODO: ! -> ?\n  protected bodyLength!: number; // TODO: ! -> ?\n  protected buffer = Buffer.alloc(0);\n  constructor(protected headerSize: number, protected callback: ProtocolReaderCallback) {\n    this.onData = this.onData.bind(this);\n  }\n\n  /** Returns length of body, or -1 if header doesn't contain length */\n  protected abstract parseHeader(data: Buffer): number;\n  protected abstract parseBody(data: Buffer): any;\n\n  onData(data?: Buffer) {\n    try {\n      // if there's data, add it on to existing buffer\n      this.buffer = data ? Buffer.concat([this.buffer, data]) : this.buffer;\n      // we haven't gotten the body length from the header yet\n      if (!this.bodyLength) {\n        if (this.buffer.length < this.headerSize) {\n          // partial header, wait for rest\n          return;\n        }\n        this.bodyLength = this.parseHeader(this.buffer);\n        // move on to body\n        this.buffer = this.buffer.slice(this.headerSize);\n        if (!this.buffer.length) {\n          // only got header, wait for body\n          return;\n        }\n      }\n      if (this.buffer.length < this.bodyLength) {\n        // wait for rest of body\n        return;\n      }\n\n      if (this.bodyLength === -1) {\n        this.callback(this.parseBody(this.buffer));\n        this.buffer = Buffer.alloc(0);\n      } else {\n        this.body = this.buffer.slice(0, this.bodyLength);\n        this.bodyLength -= this.body.length;\n        if (!this.bodyLength) {\n          this.callback(this.parseBody(this.body));\n        }\n        this.buffer = this.buffer.slice(this.body.length);\n        // There are multiple messages here, call parse again\n        if (this.buffer.length) {\n          this.onData();\n        }\n      }\n    } catch (err: any) {\n      this.callback(null, err);\n    }\n  }\n}\n\nexport abstract class PlistProtocolReader extends ProtocolReader {\n  protected parseBody(body: Buffer) {\n    if (BPLIST_MAGIC.compare(body, 0, 8) === 0) {\n      return parsePlistBuffer(body);\n    } else {\n      return plist.parse(body.toString('utf8'));\n    }\n  }\n}\n\nexport interface ProtocolWriter {\n  write(sock: net.Socket, msg: any): void;\n}\n\nexport abstract class ProtocolClient<MessageType = any> {\n  constructor(\n    public socket: net.Socket,\n    protected readerFactory: ProtocolReaderFactory<ProtocolReader>,\n    protected writer: ProtocolWriter\n  ) {}\n\n  sendMessage<ResponseType = any>(msg: MessageType): Promise<ResponseType>;\n  sendMessage<CallbackType = void, ResponseType = any>(\n    msg: MessageType,\n    callback: (response: ResponseType, resolve: any, reject: any) => void\n  ): Promise<CallbackType>;\n  sendMessage<CallbackType = void, ResponseType = any>(\n    msg: MessageType,\n    callback?: (response: ResponseType, resolve: any, reject: any) => void\n  ): Promise<CallbackType | ResponseType> {\n    return new Promise<ResponseType | CallbackType>((resolve, reject) => {\n      const reader = this.readerFactory.create(async (resp: ResponseType, err?: Error) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        if (callback) {\n          callback(\n            resp,\n            (value: any) => {\n              this.socket.removeListener('data', reader.onData);\n              resolve(value);\n            },\n            reject\n          );\n        } else {\n          this.socket.removeListener('data', reader.onData);\n          resolve(resp);\n        }\n      });\n      this.socket.on('data', reader.onData);\n      this.writer.write(this.socket, msg);\n    });\n  }\n}\n"],"mappings":"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"}
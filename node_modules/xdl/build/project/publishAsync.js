"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishAsync = publishAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _formData() {
  const data = _interopRequireDefault(require("form-data"));

  _formData = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function publishAsync(projectRoot, options = {}) {
  var _options$target, _bundles$android$herm, _bundles$android, _bundles$android2, _bundles$ios$hermesBy, _bundles$ios, _bundles$ios2, _ref, _bundles$android$herm2, _bundles$android3, _bundles$android4, _ref2, _bundles$ios$hermesSo, _bundles$ios3, _bundles$ios4, _exp$ios, _exp$android, _options$releaseChann;

  options.target = (_options$target = options.target) !== null && _options$target !== void 0 ? _options$target : (0, _config().getDefaultTarget)(projectRoot);
  const target = options.target;
  const user = await _internal().UserManager.ensureLoggedInAsync();

  if (_internal().Env.isDebug()) {
    console.log();
    console.log('Publish Assets:');
    console.log(`- Asset target: ${target}`);
    console.log();
  }

  _internal().Analytics.logEvent('Publish', {
    developerTool: _internal().Config.developerTool
  });

  const validationStatus = await _internal().Doctor.validateWithNetworkAsync(projectRoot);

  if (validationStatus === _internal().Doctor.ERROR || validationStatus === _internal().Doctor.FATAL) {
    throw new (_internal().XDLError)('PUBLISH_VALIDATION_ERROR', "Couldn't publish because errors were found. (See logs above.) Please fix the errors and try again.");
  } // Get project config


  const {
    exp,
    pkg,
    hooks
  } = await (0, _internal().getPublishExpConfigAsync)(projectRoot, options); // TODO: refactor this out to a function, throw error if length doesn't match

  const validPostPublishHooks = (0, _internal().prepareHooks)(hooks, 'postPublish', projectRoot);
  const bundles = await (0, _internal().createBundlesAsync)(projectRoot, options, {
    platforms: ['ios', 'android'],
    useDevServer: _internal().Env.shouldUseDevServer(exp)
  });
  (0, _internal().printBundleSizes)(bundles);
  await _internal().ProjectAssets.publishAssetsAsync({
    projectRoot,
    exp,
    bundles
  });
  const androidBundle = (_bundles$android$herm = (_bundles$android = bundles.android) === null || _bundles$android === void 0 ? void 0 : _bundles$android.hermesBytecodeBundle) !== null && _bundles$android$herm !== void 0 ? _bundles$android$herm : (_bundles$android2 = bundles.android) === null || _bundles$android2 === void 0 ? void 0 : _bundles$android2.code;
  const iosBundle = (_bundles$ios$hermesBy = (_bundles$ios = bundles.ios) === null || _bundles$ios === void 0 ? void 0 : _bundles$ios.hermesBytecodeBundle) !== null && _bundles$ios$hermesBy !== void 0 ? _bundles$ios$hermesBy : (_bundles$ios2 = bundles.ios) === null || _bundles$ios2 === void 0 ? void 0 : _bundles$ios2.code;
  const hasHooks = validPostPublishHooks.length > 0;
  const androidSourceMap = hasHooks ? (_ref = (_bundles$android$herm2 = (_bundles$android3 = bundles.android) === null || _bundles$android3 === void 0 ? void 0 : _bundles$android3.hermesSourcemap) !== null && _bundles$android$herm2 !== void 0 ? _bundles$android$herm2 : (_bundles$android4 = bundles.android) === null || _bundles$android4 === void 0 ? void 0 : _bundles$android4.map) !== null && _ref !== void 0 ? _ref : null : null;
  const iosSourceMap = hasHooks ? (_ref2 = (_bundles$ios$hermesSo = (_bundles$ios3 = bundles.ios) === null || _bundles$ios3 === void 0 ? void 0 : _bundles$ios3.hermesSourcemap) !== null && _bundles$ios$hermesSo !== void 0 ? _bundles$ios$hermesSo : (_bundles$ios4 = bundles.ios) === null || _bundles$ios4 === void 0 ? void 0 : _bundles$ios4.map) !== null && _ref2 !== void 0 ? _ref2 : null : null;
  let response;

  try {
    response = await _uploadArtifactsAsync({
      pkg,
      exp,
      iosBundle,
      androidBundle,
      options
    });
  } catch (e) {
    if (e.serverError === 'SCHEMA_VALIDATION_ERROR') {
      throw new Error(`There was an error validating your project schema. Check for any warnings about the contents of your app.json or app.config.js.`);
    }

    throw e;
  }

  let androidManifest = {};
  let iosManifest = {};
  const fullManifestUrl = response.url.replace('exp://', 'https://');

  if (validPostPublishHooks.length || (_exp$ios = exp.ios) !== null && _exp$ios !== void 0 && _exp$ios.publishManifestPath || (_exp$android = exp.android) !== null && _exp$android !== void 0 && _exp$android.publishManifestPath || _internal().EmbeddedAssets.shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target)) {
    const sdkOrRuntimeVersion = exp.runtimeVersion ? {
      'expo-runtime-version': exp.runtimeVersion
    } : {
      'expo-sdk-version': exp.sdkVersion
    };
    [androidManifest, iosManifest] = await Promise.all([_internal().ExponentTools.getManifestAsync(response.url, { ...sdkOrRuntimeVersion,
      'Exponent-Platform': 'android',
      'Expo-Release-Channel': options.releaseChannel,
      Accept: 'application/expo+json,application/json'
    }), _internal().ExponentTools.getManifestAsync(response.url, { ...sdkOrRuntimeVersion,
      'Exponent-Platform': 'ios',
      'Expo-Release-Channel': options.releaseChannel,
      Accept: 'application/expo+json,application/json'
    })]);
    const hookOptions = {
      url: response.url,
      exp,
      iosBundle,
      iosSourceMap,
      iosManifest,
      iosManifestUrl: fullManifestUrl,
      androidBundle,
      androidSourceMap,
      androidManifest,
      androidManifestUrl: fullManifestUrl,
      projectRoot,
      log: msg => {
        _internal().Logger.global.info({
          quiet: true
        }, msg);
      }
    };

    for (const hook of validPostPublishHooks) {
      _internal().Logger.global.info(`Running postPublish hook: ${hook.file}`);

      try {
        (0, _internal().runHook)(hook, hookOptions);
      } catch (e) {
        _internal().Logger.global.warn(`Warning: postPublish hook '${hook.file}' failed: ${e.stack}`);
      }
    }
  }

  await _internal().EmbeddedAssets.configureAsync({
    projectRoot,
    pkg,
    exp,
    releaseChannel: (_options$releaseChann = options.releaseChannel) !== null && _options$releaseChann !== void 0 ? _options$releaseChann : 'default',
    iosManifestUrl: fullManifestUrl,
    iosManifest,
    iosBundle,
    androidManifestUrl: fullManifestUrl,
    androidManifest,
    androidBundle,
    target
  }); // TODO: move to postPublish hook

  if (exp.isKernel) {
    await _handleKernelPublishedAsync({
      user,
      exp,
      projectRoot,
      url: response.url
    });
  } // Create project manifest URL


  const url = options.releaseChannel && options.releaseChannel !== 'default' ? `${response.url}?release-channel=${options.releaseChannel}` : response.url;
  const projectPageUrl = createProjectPageURL({
    projectPageUrl: response.projectPageUrl,
    releaseChannel: options.releaseChannel
  });
  return { ...response,
    url,
    projectPageUrl
  };
}

async function _uploadArtifactsAsync({
  exp,
  iosBundle,
  androidBundle,
  options,
  pkg
}) {
  _internal().Logger.global.info('');

  _internal().Logger.global.info('Uploading JavaScript bundles');

  const formData = new (_formData().default)();
  formData.append('expJson', JSON.stringify(exp));
  formData.append('packageJson', JSON.stringify(pkg));
  formData.append('iosBundle', iosBundle, 'iosBundle');
  formData.append('androidBundle', androidBundle, 'androidBundle');
  formData.append('options', JSON.stringify(options));
  const user = await _internal().UserManager.ensureLoggedInAsync();

  const api = _internal().ApiV2.clientForUser(user);

  return await api.uploadFormDataAsync('publish/new', formData);
}

async function _handleKernelPublishedAsync({
  projectRoot,
  user,
  exp,
  url
}) {
  var _exp$kernel, _exp$kernel2;

  let owner = exp.owner;

  if (!owner) {
    if (user.kind !== 'user') {
      throw new (_internal().XDLError)('ROBOT_ACCOUNT_ERROR', 'Kernel builds are not available for robot users when owner app.json field is not supplied');
    }

    owner = user.username;
  }

  let kernelBundleUrl = `${_internal().Config.api.scheme}://${_internal().Config.api.host}`;

  if (_internal().Config.api.port) {
    kernelBundleUrl = `${kernelBundleUrl}:${_internal().Config.api.port}`;
  }

  kernelBundleUrl = `${kernelBundleUrl}/@${owner}/${exp.slug}/bundle`;
  const sdkOrRuntimeVersion = exp.runtimeVersion ? {
    'expo-runtime-version': exp.runtimeVersion
  } : {
    'expo-sdk-version': exp.sdkVersion
  };

  if ((_exp$kernel = exp.kernel) !== null && _exp$kernel !== void 0 && _exp$kernel.androidManifestPath) {
    const manifest = await _internal().ExponentTools.getManifestAsync(url, { ...sdkOrRuntimeVersion,
      'Exponent-Platform': 'android',
      Accept: 'application/expo+json,application/json'
    });
    manifest.bundleUrl = kernelBundleUrl;
    manifest.sdkVersion = 'UNVERSIONED';
    await _fsExtra().default.writeFile(_path().default.resolve(projectRoot, exp.kernel.androidManifestPath), JSON.stringify(manifest));
  }

  if ((_exp$kernel2 = exp.kernel) !== null && _exp$kernel2 !== void 0 && _exp$kernel2.iosManifestPath) {
    const manifest = await _internal().ExponentTools.getManifestAsync(url, { ...sdkOrRuntimeVersion,
      'Exponent-Platform': 'ios',
      Accept: 'application/expo+json,application/json'
    });
    manifest.bundleUrl = kernelBundleUrl;
    manifest.sdkVersion = 'UNVERSIONED';
    await _fsExtra().default.writeFile(_path().default.resolve(projectRoot, exp.kernel.iosManifestPath), JSON.stringify(manifest));
  }
}

function createProjectPageURL({
  projectPageUrl,
  releaseChannel
}) {
  if (!projectPageUrl) {
    return null;
  }

  const formattedProjectUrl = `${projectPageUrl}?serviceType=classic&distribution=expo-go`;

  if (releaseChannel && releaseChannel !== 'default') {
    return `${formattedProjectUrl}&release-channel=${releaseChannel}`;
  } else {
    return formattedProjectUrl;
  }
}
//# sourceMappingURL=publishAsync.js.map
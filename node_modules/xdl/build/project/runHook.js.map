{"version":3,"file":"runHook.js","names":["requireFromProject","projectRoot","modulePath","fullPath","resolveFrom","decache","require","prepareHooks","hooks","hookType","validHooks","forEach","hook","file","fn","logger","global","error","_fn","push","undefined","length","XDLError","runHook","hookOptions","result","config","then","info","quiet"],"sources":["../../src/project/runHook.ts"],"sourcesContent":["import { ExpoConfig, Hook, HookArguments, HookType } from '@expo/config';\nimport decache from 'decache';\nimport resolveFrom from 'resolve-from';\n\nimport { Logger as logger, XDLError } from '../internal';\n\nexport type LoadedHook = Hook & {\n  _fn: (input: HookArguments) => any;\n};\n\nfunction requireFromProject(projectRoot: string, modulePath: string) {\n  try {\n    const fullPath = resolveFrom(projectRoot, modulePath);\n    // Clear the require cache for this module so get a fresh version of it\n    // without requiring the user to restart Expo CLI\n    decache(fullPath);\n    return require(fullPath);\n  } catch {\n    return null;\n  }\n}\n\nexport function prepareHooks(hooks: ExpoConfig['hooks'], hookType: HookType, projectRoot: string) {\n  const validHooks: LoadedHook[] = [];\n\n  if (hooks) {\n    if (hooks[hookType]) {\n      hooks[hookType]!.forEach((hook: any) => {\n        const { file } = hook;\n        const fn = requireFromProject(projectRoot, file);\n        if (typeof fn !== 'function') {\n          logger.global.error(\n            `Unable to load ${hookType} hook: '${file}'. The module does not export a function.`\n          );\n        } else {\n          hook._fn = fn;\n          validHooks.push(hook);\n        }\n      });\n    }\n\n    if (hooks[hookType] !== undefined && validHooks.length !== hooks[hookType]?.length) {\n      throw new XDLError(\n        'HOOK_INITIALIZATION_ERROR',\n        `Please fix your ${hookType} hook configuration`\n      );\n    }\n  }\n\n  return validHooks;\n}\n\nexport async function runHook(hook: LoadedHook, hookOptions: Omit<HookArguments, 'config'>) {\n  let result = hook._fn({\n    config: hook.config,\n    ...hookOptions,\n  });\n\n  // If it's a promise, wait for it to resolve\n  if (result && result.then) {\n    result = await result;\n  }\n\n  if (result) {\n    logger.global.info({ quiet: true }, result);\n  }\n}\n"],"mappings":";;;;;;;;AACA;EAAA;;EAAA;IAAA;EAAA;;EAAA;AAAA;;AACA;EAAA;;EAAA;IAAA;EAAA;;EAAA;AAAA;;AAEA;EAAA;;EAAA;IAAA;EAAA;;EAAA;AAAA;;;;AAMA,SAASA,kBAAT,CAA4BC,WAA5B,EAAiDC,UAAjD,EAAqE;EACnE,IAAI;IACF,MAAMC,QAAQ,GAAG,IAAAC,sBAAA,EAAYH,WAAZ,EAAyBC,UAAzB,CAAjB,CADE,CAEF;IACA;;IACA,IAAAG,kBAAA,EAAQF,QAAR;IACA,OAAOG,OAAO,CAACH,QAAD,CAAd;EACD,CAND,CAME,MAAM;IACN,OAAO,IAAP;EACD;AACF;;AAEM,SAASI,YAAT,CAAsBC,KAAtB,EAAkDC,QAAlD,EAAsER,WAAtE,EAA2F;EAChG,MAAMS,UAAwB,GAAG,EAAjC;;EAEA,IAAIF,KAAJ,EAAW;IAAA;;IACT,IAAIA,KAAK,CAACC,QAAD,CAAT,EAAqB;MACnBD,KAAK,CAACC,QAAD,CAAL,CAAiBE,OAAjB,CAA0BC,IAAD,IAAe;QACtC,MAAM;UAAEC;QAAF,IAAWD,IAAjB;QACA,MAAME,EAAE,GAAGd,kBAAkB,CAACC,WAAD,EAAcY,IAAd,CAA7B;;QACA,IAAI,OAAOC,EAAP,KAAc,UAAlB,EAA8B;UAC5BC,kBAAA,CAAOC,MAAP,CAAcC,KAAd,CACG,kBAAiBR,QAAS,WAAUI,IAAK,2CAD5C;QAGD,CAJD,MAIO;UACLD,IAAI,CAACM,GAAL,GAAWJ,EAAX;UACAJ,UAAU,CAACS,IAAX,CAAgBP,IAAhB;QACD;MACF,CAXD;IAYD;;IAED,IAAIJ,KAAK,CAACC,QAAD,CAAL,KAAoBW,SAApB,IAAiCV,UAAU,CAACW,MAAX,yBAAsBb,KAAK,CAACC,QAAD,CAA3B,oDAAsB,gBAAiBY,MAAvC,CAArC,EAAoF;MAClF,MAAM,KAAIC,oBAAJ,EACJ,2BADI,EAEH,mBAAkBb,QAAS,qBAFxB,CAAN;IAID;EACF;;EAED,OAAOC,UAAP;AACD;;AAEM,eAAea,OAAf,CAAuBX,IAAvB,EAAyCY,WAAzC,EAAqF;EAC1F,IAAIC,MAAM,GAAGb,IAAI,CAACM,GAAL,CAAS;IACpBQ,MAAM,EAAEd,IAAI,CAACc,MADO;IAEpB,GAAGF;EAFiB,CAAT,CAAb,CAD0F,CAM1F;;;EACA,IAAIC,MAAM,IAAIA,MAAM,CAACE,IAArB,EAA2B;IACzBF,MAAM,GAAG,MAAMA,MAAf;EACD;;EAED,IAAIA,MAAJ,EAAY;IACVV,kBAAA,CAAOC,MAAP,CAAcY,IAAd,CAAmB;MAAEC,KAAK,EAAE;IAAT,CAAnB,EAAoCJ,MAApC;EACD;AACF"}
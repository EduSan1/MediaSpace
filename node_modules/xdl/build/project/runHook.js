"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareHooks = prepareHooks;
exports.runHook = runHook;

function _decache() {
  const data = _interopRequireDefault(require("decache"));

  _decache = function () {
    return data;
  };

  return data;
}

function _resolveFrom() {
  const data = _interopRequireDefault(require("resolve-from"));

  _resolveFrom = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function requireFromProject(projectRoot, modulePath) {
  try {
    const fullPath = (0, _resolveFrom().default)(projectRoot, modulePath); // Clear the require cache for this module so get a fresh version of it
    // without requiring the user to restart Expo CLI

    (0, _decache().default)(fullPath);
    return require(fullPath);
  } catch {
    return null;
  }
}

function prepareHooks(hooks, hookType, projectRoot) {
  const validHooks = [];

  if (hooks) {
    var _hooks$hookType;

    if (hooks[hookType]) {
      hooks[hookType].forEach(hook => {
        const {
          file
        } = hook;
        const fn = requireFromProject(projectRoot, file);

        if (typeof fn !== 'function') {
          _internal().Logger.global.error(`Unable to load ${hookType} hook: '${file}'. The module does not export a function.`);
        } else {
          hook._fn = fn;
          validHooks.push(hook);
        }
      });
    }

    if (hooks[hookType] !== undefined && validHooks.length !== ((_hooks$hookType = hooks[hookType]) === null || _hooks$hookType === void 0 ? void 0 : _hooks$hookType.length)) {
      throw new (_internal().XDLError)('HOOK_INITIALIZATION_ERROR', `Please fix your ${hookType} hook configuration`);
    }
  }

  return validHooks;
}

async function runHook(hook, hookOptions) {
  let result = hook._fn({
    config: hook.config,
    ...hookOptions
  }); // If it's a promise, wait for it to resolve


  if (result && result.then) {
    result = await result;
  }

  if (result) {
    _internal().Logger.global.info({
      quiet: true
    }, result);
  }
}
//# sourceMappingURL=runHook.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBundlesAsync = createBundlesAsync;
exports.printBundleSizes = printBundleSizes;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _devServer() {
  const data = require("@expo/dev-server");

  _devServer = function () {
    return data;
  };

  return data;
}

function _axios() {
  const data = _interopRequireDefault(require("axios"));

  _axios = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MINIMUM_BUNDLE_SIZE = 500;

function printBundleSizes(bundles) {
  var _bundles$ios, _bundles$ios2, _bundles$android, _bundles$android2, _bundles$ios3, _bundles$ios4, _bundles$android3, _bundles$android4;

  const files = [];

  if ((_bundles$ios = bundles.ios) !== null && _bundles$ios !== void 0 && _bundles$ios.hermesBytecodeBundle) {
    files.push(['index.ios.js (Hermes)', bundles.ios.hermesBytecodeBundle]);
  } else if ((_bundles$ios2 = bundles.ios) !== null && _bundles$ios2 !== void 0 && _bundles$ios2.code) {
    files.push(['index.ios.js', bundles.ios.code]);
  }

  if ((_bundles$android = bundles.android) !== null && _bundles$android !== void 0 && _bundles$android.hermesBytecodeBundle) {
    files.push(['index.android.js (Hermes)', bundles.android.hermesBytecodeBundle]);
  } else if ((_bundles$android2 = bundles.android) !== null && _bundles$android2 !== void 0 && _bundles$android2.code) {
    files.push(['index.android.js', bundles.android.code]);
  } // Account for inline source maps


  if ((_bundles$ios3 = bundles.ios) !== null && _bundles$ios3 !== void 0 && _bundles$ios3.hermesSourcemap) {
    files.push([_chalk().default.dim('index.ios.js.map (Hermes)'), bundles.ios.hermesSourcemap]);
  } else if ((_bundles$ios4 = bundles.ios) !== null && _bundles$ios4 !== void 0 && _bundles$ios4.map) {
    files.push([_chalk().default.dim('index.ios.js.map'), bundles.ios.map]);
  }

  if ((_bundles$android3 = bundles.android) !== null && _bundles$android3 !== void 0 && _bundles$android3.hermesSourcemap) {
    files.push([_chalk().default.dim('index.android.js.map (Hermes)'), bundles.android.hermesSourcemap]);
  } else if ((_bundles$android4 = bundles.android) !== null && _bundles$android4 !== void 0 && _bundles$android4.map) {
    files.push([_chalk().default.dim('index.android.js.map'), bundles.android.map]);
  }

  _internal().Logger.global.info('');

  _internal().Logger.global.info(_internal().TableText.createFilesTable(files));

  _internal().Logger.global.info('');

  _internal().Logger.global.info(`ðŸ’¡ JavaScript bundle sizes affect startup time. ${_chalk().default.dim((0, _internal().learnMore)(`https://expo.fyi/javascript-bundle-sizes`))}`);

  _internal().Logger.global.info('');
}

async function createBundlesAsync(projectRoot, publishOptions = {}, bundleOptions) {
  if (!bundleOptions.useDevServer) {
    // The old approach is so unstable / untested that we should warn users going forward to upgrade their projects.
    _internal().Logger.global.warn('Using legacy Metro server to bundle your JavaScript code, you may encounter unexpected behavior if your project uses a custom metro.config.js file.'); // Dev server is aggressively enabled, so we can have a specific warning message:
    // - If the SDK version is UNVERSIONED or undefined, it'll be enabled.
    // - If EXPO_USE_DEV_SERVER is 0, or unset, it'll be enabled.


    _internal().Logger.global.warn(`Please upgrade your project to Expo SDK 40+. If you experience CLI issues after upgrading, try using the env var EXPO_USE_DEV_SERVER=1.`);

    try {
      await (0, _internal().startReactNativeServerAsync)({
        projectRoot,
        options: {
          nonPersistent: true,
          maxWorkers: publishOptions.maxWorkers,
          target: publishOptions.target,
          reset: publishOptions.resetCache
        },
        verbose: !publishOptions.quiet
      });
      return await fetchPublishBundlesAsync(projectRoot);
    } finally {
      await (0, _internal().stopReactNativeServerAsync)(projectRoot);
    }
  }

  const config = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  });
  const isLegacy = (0, _config().isLegacyImportsEnabled)(config.exp);
  const bundles = await (0, _devServer().bundleAsync)(projectRoot, config.exp, {
    // If not legacy, ignore the target option to prevent warnings from being thrown.
    target: !isLegacy ? undefined : publishOptions.target,
    resetCache: publishOptions.resetCache,
    maxWorkers: publishOptions.maxWorkers,
    logger: _internal().ProjectUtils.getLogger(projectRoot),
    quiet: publishOptions.quiet,
    unversioned: !config.exp.sdkVersion || config.exp.sdkVersion === 'UNVERSIONED'
  }, bundleOptions.platforms.map(platform => ({
    platform,
    entryPoint: (0, _internal().resolveEntryPoint)(projectRoot, platform),
    dev: bundleOptions.dev
  }))); // { ios: bundle, android: bundle }

  const results = {};

  for (let index = 0; index < bundleOptions.platforms.length; index++) {
    const platform = bundleOptions.platforms[index];
    const bundle = bundles[index];
    results[platform] = bundle;
  }

  return results;
} // Fetch iOS and Android bundles for publishing


async function fetchPublishBundlesAsync(projectRoot, opts) {
  const entryPoint = (0, _internal().resolveEntryPoint)(projectRoot);
  const publishUrl = await _internal().UrlUtils.constructPublishUrlAsync(projectRoot, entryPoint, undefined, opts);
  const sourceMapUrl = await _internal().UrlUtils.constructSourceMapUrlAsync(projectRoot, entryPoint);
  const assetsUrl = await _internal().UrlUtils.constructAssetsUrlAsync(projectRoot, entryPoint);

  _internal().Logger.global.info('Building iOS bundle');

  const iosBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'ios', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _internal().Logger.global.info('Building Android bundle');

  const androidBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'android', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _internal().Logger.global.info('Building source maps');

  const iosSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'ios', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });
  const androidSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'android', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _internal().Logger.global.info('Building asset maps');

  const iosAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'ios', {
    errorCode: 'INVALID_ASSETS'
  });
  const androidAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'android', {
    errorCode: 'INVALID_ASSETS'
  });
  return {
    android: {
      code: androidBundle,
      map: androidSourceMap,
      assets: JSON.parse(androidAssetsJson)
    },
    ios: {
      code: iosBundle,
      map: iosSourceMap,
      assets: JSON.parse(iosAssetsJson)
    }
  };
}

async function _getForPlatformAsync(projectRoot, url, platform, {
  errorCode,
  minLength
}) {
  const fullUrl = `${url}&platform=${platform}`;
  let response;

  try {
    response = await _axios().default.request({
      url: fullUrl,
      responseType: 'text',
      // Workaround for https://github.com/axios/axios/issues/907.
      // Without transformResponse, axios will parse the body as JSON regardless of the responseType/
      transformResponse: [data => data],
      proxy: false,
      validateStatus: status => status === 200,
      headers: {
        'Exponent-Platform': platform
      }
    });
  } catch (error) {
    if (error.response) {
      if (error.response.data) {
        let body;

        try {
          body = JSON.parse(error.response.data);
        } catch {
          _internal().ProjectUtils.logError(projectRoot, 'expo', error.response.data);
        }

        if (body) {
          if (body.message) {
            _internal().ProjectUtils.logError(projectRoot, 'expo', body.message);
          } else {
            _internal().ProjectUtils.logError(projectRoot, 'expo', error.response.data);
          }
        }
      }

      throw new (_internal().XDLError)(errorCode, `Packager URL ${fullUrl} returned unexpected code ${error.response.status}. ` + 'Please open your project in the Expo app and see if there are any errors. ' + 'Also scroll up and make sure there were no errors or warnings when opening your project.');
    } else {
      throw error;
    }
  }

  if (!response.data || minLength && response.data.length < minLength) {
    throw new (_internal().XDLError)(errorCode, `Body is: ${response.data}`);
  }

  return response.data;
}
//# sourceMappingURL=createBundlesAsync.js.map
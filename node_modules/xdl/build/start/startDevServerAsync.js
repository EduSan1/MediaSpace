"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startDevServerAsync = startDevServerAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _devServer() {
  const data = require("@expo/dev-server");

  _devServer = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

async function startDevServerAsync(projectRoot, startOptions) {
  (0, _internal().assertValidProjectRoot)(projectRoot);
  let port;

  if (startOptions.metroPort != null) {
    // If the manually defined port is busy then an error should be thrown
    port = startOptions.metroPort;
  } else {
    port = startOptions.devClient ? Number(process.env.RCT_METRO_PORT) || 8081 : await (0, _internal().getFreePortAsync)(startOptions.metroPort || 19000);
  }

  await _internal().ProjectSettings.setPackagerInfoAsync(projectRoot, {
    expoServerPort: port,
    packagerPort: port
  });
  const options = {
    port,
    logger: _internal().ProjectUtils.getLogger(projectRoot),
    // @deprecated
    target: startOptions.target
  };

  if (startOptions.reset) {
    options.resetCache = true;
  }

  if (startOptions.maxWorkers != null) {
    options.maxWorkers = startOptions.maxWorkers;
  } // TODO: reduce getConfig calls


  const projectConfig = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  }); // Use the unversioned metro config.

  options.unversioned = !projectConfig.exp.sdkVersion || projectConfig.exp.sdkVersion === 'UNVERSIONED';
  const {
    server,
    middleware,
    messageSocket
  } = await (0, _devServer().runMetroDevServerAsync)(projectRoot, options);
  const useExpoUpdatesManifest = startOptions.forceManifestType === 'expo-updates'; // We need the manifest handler to be the first middleware to run so our
  // routes take precedence over static files. For example, the manifest is
  // served from '/' and if the user has an index.html file in their project
  // then the manifest handler will never run, the static middleware will run
  // and serve index.html instead of the manifest.
  // https://github.com/expo/expo/issues/13114

  (0, _devServer().prependMiddleware)(middleware, useExpoUpdatesManifest ? _internal().ExpoUpdatesManifestHandler.getManifestHandler(projectRoot) : _internal().ManifestHandler.getManifestHandler(projectRoot));
  middleware.use(_internal().LoadingPageHandler.getLoadingPageHandler(projectRoot));
  return [server, middleware, messageSocket];
}
//# sourceMappingURL=startDevServerAsync.js.map
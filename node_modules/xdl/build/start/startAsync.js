"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.broadcastMessage = broadcastMessage;
exports.startAsync = startAsync;
exports.stopAsync = stopAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _devServer() {
  const data = require("@expo/dev-server");

  _devServer = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _watchBabelConfig() {
  const data = require("./watchBabelConfig");

  _watchBabelConfig = function () {
    return data;
  };

  return data;
}

let serverInstance = null;
let messageSocket = null;
/**
 * Sends a message over web sockets to any connected device,
 * does nothing when the dev server is not running.
 *
 * @param method name of the command. In RN projects `reload`, and `devMenu` are available. In Expo Go, `sendDevCommand` is available.
 * @param params
 */

function broadcastMessage(method, params) {
  if (messageSocket) {
    messageSocket.broadcast(method, params);
  }
}

async function startAsync(projectRoot, {
  exp = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  }).exp,
  ...options
} = {}, verbose = true) {
  var _exp$sdkVersion;

  (0, _internal().assertValidProjectRoot)(projectRoot);

  _internal().Analytics.logEvent('Start Project', {
    developerTool: _internal().Config.developerTool,
    sdkVersion: (_exp$sdkVersion = exp.sdkVersion) !== null && _exp$sdkVersion !== void 0 ? _exp$sdkVersion : null
  });

  (0, _watchBabelConfig().watchBabelConfigForProject)(projectRoot);

  if (options.webOnly) {
    await _internal().Webpack.startAsync(projectRoot, { ...options,
      port: options.webpackPort
    });
  } else if (_internal().Env.shouldUseDevServer(exp) || options.devClient) {
    [serverInstance,, messageSocket] = await (0, _internal().startDevServerAsync)(projectRoot, options);
  } else {
    await (0, _internal().startExpoServerAsync)(projectRoot);
    await (0, _internal().startReactNativeServerAsync)({
      projectRoot,
      exp,
      options,
      verbose
    });
  }

  const {
    hostType
  } = await _internal().ProjectSettings.readAsync(projectRoot);

  if (!_internal().ConnectionStatus.isOffline() && hostType === 'tunnel') {
    try {
      await (0, _internal().startTunnelsAsync)(projectRoot);
    } catch (e) {
      _internal().ProjectUtils.logError(projectRoot, 'expo', `Error starting ngrok: ${e.message}`);
    }
  }

  const target = !options.webOnly || _internal().Webpack.isTargetingNative() ? 'native' : 'web'; // This is used to make Expo Go open the project in either Expo Go, or the web browser.
  // Must come after ngrok (`startTunnelsAsync`) setup.

  _internal().DevSession.startSession(projectRoot, exp, target);

  return exp;
}

async function stopDevServerAsync() {
  return new Promise((resolve, reject) => {
    if (serverInstance) {
      (0, _devServer().closeJsInspector)();
      serverInstance.close(error => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    }
  });
}

async function stopInternalAsync(projectRoot) {
  _internal().DevSession.stopSession();

  await Promise.all([_internal().Webpack.stopAsync(projectRoot), stopDevServerAsync(), (0, _internal().stopExpoServerAsync)(projectRoot), (0, _internal().stopReactNativeServerAsync)(projectRoot), async () => {
    if (!_internal().ConnectionStatus.isOffline()) {
      try {
        await (0, _internal().stopTunnelsAsync)(projectRoot);
      } catch (e) {
        _internal().ProjectUtils.logError(projectRoot, 'expo', `Error stopping ngrok: ${e.message}`);
      }
    }
  }, await _internal().Android.maybeStopAdbDaemonAsync()]);
}

async function forceQuitAsync(projectRoot) {
  // find RN packager and ngrok pids, attempt to kill them manually
  const {
    packagerPid,
    ngrokPid
  } = await _internal().ProjectSettings.readPackagerInfoAsync(projectRoot);

  if (packagerPid) {
    try {
      process.kill(packagerPid);
    } catch {}
  }

  if (ngrokPid) {
    try {
      process.kill(ngrokPid);
    } catch {}
  }

  await _internal().ProjectSettings.setPackagerInfoAsync(projectRoot, {
    expoServerPort: null,
    packagerPort: null,
    packagerPid: null,
    expoServerNgrokUrl: null,
    packagerNgrokUrl: null,
    ngrokPid: null,
    webpackServerPort: null
  });
}

async function stopAsync(projectRoot) {
  try {
    const result = await Promise.race([stopInternalAsync(projectRoot), new Promise(resolve => setTimeout(resolve, 2000, 'stopFailed'))]);

    if (result === 'stopFailed') {
      await forceQuitAsync(projectRoot);
    }
  } catch (error) {
    await forceQuitAsync(projectRoot);
    throw error;
  }
}
//# sourceMappingURL=startAsync.js.map
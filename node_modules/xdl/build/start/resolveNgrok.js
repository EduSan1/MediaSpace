"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveNgrokAsync = resolveNgrokAsync;

function PackageManager() {
  const data = _interopRequireWildcard(require("@expo/package-manager"));

  PackageManager = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _requireg() {
  const data = _interopRequireDefault(require("requireg"));

  _requireg = function () {
    return data;
  };

  return data;
}

function _resolveFrom() {
  const data = _interopRequireDefault(require("resolve-from"));

  _resolveFrom = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @ts-ignore
const NGROK_REQUIRED_VERSION = '^4.1.0';

const EXPO_DEBUG = _getenv().default.boolish('EXPO_DEBUG', false);

let _ngrokInstance = null;

async function resolveNgrokAsync(projectRoot, {
  shouldPrompt = true,
  autoInstall = false
} = {}) {
  const ngrok = await findNgrokBinAsync(projectRoot);

  if (!ngrok) {
    const packageName = `@expo/ngrok@${NGROK_REQUIRED_VERSION}`;

    if (shouldPrompt) {
      if (!autoInstall) {
        // Delay the prompt so it doesn't conflict with other dev tool logs
        await (0, _internal().delayAsync)(100);
      }

      const answer = autoInstall || (await _internal().Prompts.confirmAsync({
        message: `The package ${packageName} is required to use tunnels, would you like to install it globally?`,
        initial: true
      }));

      if (answer) {
        _internal().Logger.global.info(`Installing ${packageName} for ${_chalk().default.bold`tunnel`} support...`);

        const packageManager = PackageManager().createForProject(projectRoot, {
          silent: !EXPO_DEBUG
        });

        try {
          await packageManager.addGlobalAsync(packageName);

          _internal().Logger.global.info(`Successfully installed ${packageName}`);
        } catch (e) {
          e.message = `Failed to install ${packageName} globally: ${e.message}`;
          throw e;
        }

        return await resolveNgrokAsync(projectRoot, {
          shouldPrompt: false
        });
      }
    }

    throw new Error(`Please install ${packageName} and try again, or try using another hosting method like lan or localhost`);
  }

  return ngrok;
} // Resolve a copy that's installed in the project.


async function resolvePackageFromProjectAsync(projectRoot) {
  try {
    const ngrokPackagePath = (0, _resolveFrom().default)(projectRoot, '@expo/ngrok/package.json');

    const pkg = require(ngrokPackagePath);

    if (pkg && _semver().default.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {
      const ngrokPath = (0, _resolveFrom().default)(projectRoot, '@expo/ngrok');

      _internal().Logger.global.debug(`Resolving @expo/ngrok from project: "${ngrokPath}"`);

      return require(ngrokPath);
    }
  } catch {}

  return null;
} // Resolve a copy that's installed globally.


async function resolveGlobalPackageAsync() {
  try {
    // use true to disable the use of local packages.
    const pkg = (0, _requireg().default)('@expo/ngrok/package.json', true);

    if (_semver().default.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {
      _internal().Logger.global.debug(`Resolving global @expo/ngrok from: "${_requireg().default.resolve('@expo/ngrok')}"`);

      return (0, _requireg().default)('@expo/ngrok', true);
    }
  } catch {}

  return null;
}

async function findNgrokBinAsync(projectRoot) {
  if (_ngrokInstance) {
    return _ngrokInstance;
  }

  const localInstance = await resolvePackageFromProjectAsync(projectRoot);

  if (localInstance) {
    _ngrokInstance = localInstance;
    return _ngrokInstance;
  }

  const globalInstance = await resolveGlobalPackageAsync();

  if (globalInstance) {
    _ngrokInstance = globalInstance;
    return _ngrokInstance;
  }

  return null;
}
//# sourceMappingURL=resolveNgrok.js.map
import { ExpoConfig } from '@expo/config-types';
import { Semaphore, UserData } from './internal';
export declare type User = {
    kind: 'user';
    username: string;
    nickname: string;
    userId: string;
    picture: string;
    email?: string;
    emailVerified?: boolean;
    givenName?: string;
    familyName?: string;
    userMetadata: {
        onboarded: boolean;
        legacy?: boolean;
    };
    currentConnection: ConnectionType;
    sessionSecret?: string;
    accessToken?: string;
};
export declare type RobotUser = {
    kind: 'robot';
    userId: string;
    username: string;
    givenName?: string;
    currentConnection: ConnectionType;
    sessionSecret?: never;
    accessToken?: string;
};
export declare type LegacyUser = {
    kind: 'legacyUser';
    username: string;
    userMetadata: {
        legacy: boolean;
        needsPasswordMigration: boolean;
    };
};
export declare type UserOrLegacyUser = User | LegacyUser;
export declare type ConnectionType = 'Access-Token-Authentication' | 'Username-Password-Authentication' | 'facebook' | 'google-oauth2' | 'github';
export declare type RegistrationData = {
    username: string;
    password: string;
    email?: string;
    givenName?: string;
    familyName?: string;
};
export declare type LoginType = 'user-pass' | 'facebook' | 'google' | 'github';
export declare const ANONYMOUS_USERNAME = "anonymous";
export declare class UserManagerInstance {
    _currentUser: User | RobotUser | null;
    _getSessionLock: Semaphore;
    _interactiveAuthenticationCallbackAsync?: () => Promise<User>;
    static getGlobalInstance(): UserManagerInstance;
    initialize(): void;
    /**
     * Get the account and project name using a user and Expo config.
     * This will validate if the owner field is set when using a robot account.
     */
    getProjectOwner(user: User | RobotUser, exp: ExpoConfig): string;
    /**
     * Logs in a user for a given login type.
     *
     * Valid login types are:
     *  - "user-pass": Username and password authentication
     *
     * If the login type is "user-pass", we directly make the request to www
     * to login a user.
     */
    loginAsync(loginType: LoginType, loginArgs?: {
        username: string;
        password: string;
        otp?: string;
    }): Promise<User>;
    registerAsync(userData: RegistrationData, user?: UserOrLegacyUser | null): Promise<User>;
    /**
     * Ensure user is logged in and has a valid token.
     *
     * If there are any issues with the login, this method throws.
     */
    ensureLoggedInAsync(): Promise<User | RobotUser>;
    setInteractiveAuthenticationCallback(callback: () => Promise<User>): void;
    _readUserData(): Promise<UserData | null>;
    /**
     * Returns cached user data without hitting our backend. Only works for 'Username-Password-Authentication' flow. Does not work with 'Access-Token-Authentication' flow.
     */
    getCachedUserDataAsync: () => Promise<UserData | null>;
    /**
     * Get the current user based on the available token.
     * If there is no current token, returns null.
     */
    getCurrentUserAsync(options?: {
        silent?: boolean;
    }): Promise<User | RobotUser | null>;
    /**
     * Get the current user and check if it's a robot.
     * If the user is not a robot, it will throw an error.
     */
    getCurrentUserOnlyAsync(): Promise<User | null>;
    /**
     * Get the current user and check if it's a robot.
     * If the user is not a robot, it will throw an error.
     */
    getCurrentRobotUserOnlyAsync(): Promise<RobotUser | null>;
    getCurrentUsernameAsync(): Promise<string | null>;
    getSessionAsync(): Promise<{
        sessionSecret?: string;
        accessToken?: string;
    } | null>;
    /**
     * Create or update a user.
     */
    createOrUpdateUserAsync(userData: object): Promise<User | null>;
    /**
     * Logout
     */
    logoutAsync(): Promise<void>;
    /**
     * Forgot Password
     */
    forgotPasswordAsync(usernameOrEmail: string): Promise<void>;
    /**
     * Get profile given token data. Errors if token is not valid or if no
     * user profile is returned.
     *
     * This method is called by all public authentication methods of `UserManager`
     * except `logoutAsync`. Therefore, we use this method as a way to:
     *  - update the UserSettings store with the current token and user id
     *  - update UserManager._currentUser
     *  - Fire login analytics events
     *
     * Also updates UserManager._currentUser.
     *
     * @private
     */
    _getProfileAsync({ currentConnection, sessionSecret, accessToken, }: {
        currentConnection?: ConnectionType;
        sessionSecret?: string;
        accessToken?: string;
    }): Promise<User | RobotUser>;
}
declare const _default: UserManagerInstance;
export default _default;

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Logger = exports.LogLevel = void 0;
exports.pipeOutputToLogger = pipeOutputToLogger;

function _bunyan() {
  const data = _interopRequireDefault(require("@expo/bunyan"));

  _bunyan = function () {
    return data;
  };

  return data;
}

function _isEmpty() {
  const data = _interopRequireDefault(require("lodash/isEmpty"));

  _isEmpty = function () {
    return data;
  };

  return data;
}

function _isPlainObject() {
  const data = _interopRequireDefault(require("lodash/isPlainObject"));

  _isPlainObject = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let LogLevel;
exports.LogLevel = LogLevel;

(function (LogLevel) {
  LogLevel["trace"] = "trace";
  LogLevel["debug"] = "debug";
  LogLevel["info"] = "info";
  LogLevel["warn"] = "warn";
  LogLevel["error"] = "error";
  LogLevel["fatal"] = "fatal";
})(LogLevel || (exports.LogLevel = LogLevel = {}));

class Logger {
  constructor(bunyanGetter, extraFields) {
    _defineProperty(this, "loggerObj", void 0);

    _defineProperty(this, "loggerGetter", void 0);

    _defineProperty(this, "extraFields", void 0);

    this.loggerObj = _bunyan().default.createLogger({
      name: 'xdl-detach'
    });
    this.loggerGetter = bunyanGetter;
    this.extraFields = extraFields;
  }

  configure(loggerObj) {
    this.loggerObj = loggerObj;
  }

  withFields(extraFields) {
    const getter = this.loggerGetter || (() => this.loggerObj);

    return new Logger(getter, { ...this.extraFields,
      ...extraFields
    });
  }

  trace(...all) {
    this.logLine(LogLevel.trace, ...all);
  }

  debug(...all) {
    this.logLine(LogLevel.debug, ...all);
  }

  info(...all) {
    this.logLine(LogLevel.info, ...all);
  }

  warn(...all) {
    this.logLine(LogLevel.warn, ...all);
  }

  error(...all) {
    this.logLine(LogLevel.error, ...all);
  }

  fatal(...all) {
    this.logLine(LogLevel.fatal, ...all);
  }

  logLine(level, ...args) {
    const argsToLog = [...args];
    const extraFieldsFromArgsExist = (0, _isPlainObject().default)(args[0]);
    const extraFieldsFromArgs = extraFieldsFromArgsExist ? args[0] : {};

    if (extraFieldsFromArgsExist) {
      argsToLog.shift();
    }

    const extraFields = { ...extraFieldsFromArgs,
      ...this.extraFields
    };

    if (!(0, _isEmpty().default)(extraFields)) {
      argsToLog.unshift(extraFields);
    }

    if (this.loggerGetter) {
      const loggerObj = this.loggerGetter();
      loggerObj[level](...argsToLog);
    } else {
      this.loggerObj[level](...argsToLog);
    }
  }

}

exports.Logger = Logger;
const LoggerDetach = new Logger();
var _default = LoggerDetach;
exports.default = _default;

function pipeOutputToLogger({
  stdout,
  stderr
} = {
  stdout: null,
  stderr: null
}, extraFields = {}, {
  stdoutOnly = false,
  loggerLineTransformer
} = {}) {
  if (stdout) {
    stdout.on('data', chunk => logMultiline(chunk, { ...extraFields,
      source: 'stdout'
    }, loggerLineTransformer));
  }

  if (stderr) {
    const source = stdoutOnly ? 'stdout' : 'stderr';
    stderr.on('data', chunk => logMultiline(chunk, { ...extraFields,
      source
    }, loggerLineTransformer));
  }
}

function logMultiline(data, extraFields, loggerLineTransformer) {
  if (!data) {
    return;
  }

  const lines = String(data).split('\n');
  lines.forEach(line => {
    const lineToPrint = loggerLineTransformer ? loggerLineTransformer(line) : line;

    if (lineToPrint) {
      const args = [lineToPrint];

      if (!(0, _isEmpty().default)(extraFields)) {
        args.unshift(extraFields);
      }

      LoggerDetach.info(...args);
    }
  });
}
//# sourceMappingURL=Logger.js.map